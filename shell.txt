shell
    开头  #!/bin/sh    带export的是设置环境变量
    运算符
        1）数值测试：
        　　-eq 等于则为真。
        　　-ne 不等于则为真。
        　　-gt 大于则为真。
           -ge 大于等于则为真。
       　　 -lt 小于则为真。
        　　-le 小于等于则为真。

        （2）字串测试：
        　　= 等于则为真。
        　　!= 不相等则为真。
        　　-z字串 字串长度伪则为真。
        　　-n字串 字串长度不伪则为真。

        （3）文件测试：
        　　-e文件名 如果文件存在则为真。
        　　-r文件名 如果文件存在且可读则为真。
        　　-w文件名 如果文件存在且可写则为真。
        　　-x文件名 如果文件存在且可执行则为真。
        　　-s文件名 如果文件存在且至少有一个字符则为真。
        　　-d文件名 如果文件存在且为目录则为真。
        　　-f文件名 如果文件存在且为普通文件则为真。
        　　-c文件名 如果文件存在且为字符型特殊文件则为真。
        　　-b文件名 如果文件存在且为块特殊文件则为真
        条件变量替换:
            (1) ${value:-word} 当变量未定义或者值为空时,返回值为word的内容,否则返回变量的值. 
            (2) ${value:=word} 与前者类似,只是若变量未定义或者值为空时,在返回word的值的同时将 word赋值给value 
            (3) ${value:+word} 若变量已赋值的话,其值才用word替换,否则不进行任何替换 
       
    控制语句
        if[] then  elif  then  else  fi
            通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。 
            [ -f “somefile” ] :判断是否是一个文件 
            [ -x “/bin/ls” ] :判断/bin/ls是否存在并有可执行权限 
            [ -n “$var” ] :判断$var变量是否有值 
            [ “$a” = “$b” ] :判断$a和$b是否相等
        case … in 
            ...) .... ;; 
            esac 
        # 获取月份最大日期 
            get_mon_days() 
            { 
            Y=`expr substr $1 1 4` 
            M=`expr substr $1 5 2` 
            case "$M" in 
            01|03|05|07|08|10|12) days=31;; 
            04|06|09|11) days=30;; 
            02) 
            _tmpStr=`check_leap "$Y"` #判断是否闰年 
            if [ "$_tmpStr" = "true" ] ; then 
            #闰年 
            days=29 
            else 
            days=28 
            fi 
            ;; 
            *) days=0 ;; 
            esac 
            echo $days 
            } 
    date
        date +%y%m%d   +表示按照指定格式显示
        date -d -2day +%Y%m%d     显示两天之前的日期并按指定格式显示
        date --date="20181010" +%Y-%m-%d    日期格式转换  20181010--->2018-10-10   

    other
        入参
            $0 这个程式的执行名字
            $n 这个程式的第n个参数值，n=1..9
            $* 这个程式的所有参数,此选项参数可超过9个。
            $# 这个程式的参数个数
            $$ 这个程式的PID(脚本运行的当前进程ID号)
            $! 执行上一个背景指令的PID(后台运行的最后一个进程的进程ID号)
            $? 执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)
            $- 显示shell使用的当前选项，与set命令功能相同
            $@ 跟$*类似，但是可以当作数组用
        函数
            `expr substr $1 1 4`   执行字符串截取
            
            > 写入文件并覆盖旧文件 
            >> 加到文件的尾部,保留旧文件内容。
            find
    定期执行脚本 crontab
    文本处理
        gerp 查找, sed 编辑, awk 根据内容分析并处理
        grep “hello” file.txt | wc -l    在file.txt中搜索包含有”hello”的行并计算其行数。
            grep(关键字: 截取) 文本搜集工具, 结合正则表达式非常强大
            主要参数 
            -c : 只输出匹配的行
            -I : 不区分大小写
            -h : 查询多文件时不显示文件名
            -l : 查询多文件时, 只输出包含匹配字符的文件名
            -n : 显示匹配的行号及行
            -v : 显示不包含匹配文本的所有行(我经常用除去grep本身)
            基本工作方式: grep 要匹配的内容 文件名, 例如:
            grep 'test' d* 显示所有以d开头的文件中包含test的行
            grep 'test' aa bb cc 显示在 aa bb cc 文件中包含test的行
            grep '[a-z]\{5}\' aa 显示所有包含字符串至少有5个连续小写字母的串
        sed 以行为单位的文本编辑工具   基本工作方式: sed [-nei] '[动作]' [输入文本]
            -n : 安静模式, 一般sed用法中, 来自stdin的数据一般会被列出到屏幕上, 如果使用-n参数后, 只有经过sed处理的那一行被列出来.
            -e : 多重编辑, 比如你同时又想删除某行, 又想改变其他行, 那么可以用 sed -e '1,5d' -e 's/abc/xxx/g' filename
            -i : 直接编辑, 这回就是真的改变文件中的内容了, 别的都只是改变显示. (不推荐使用,一般处理的是标准输入流)
            a 新增, a 后面可以接字符串, 而这个字符串会在新的一行出现. (下一行)
            c 取代, c 后面的字符串, 这些字符串可以取代 n1,n2之间的行
            d 删除, 后面不接任何东西
            i 插入, 后面的字符串, 会在上一行出现
            p 打印, 将选择的资料列出, 通常和 sed -n 一起运作 sed -n '3p' 只打印第3行
            s 取代, 类似vi中的取代, 1,20s/old/new/g
            w file, 匹配到的行写入某文件  例如: sed -n '/m/w qqq' abc , 从abc中读取带m的行写到qqq文件中, 注意, 这个写入带有覆盖性.
                sed '1d' abc 删除 abc 档案里的第一行, 注意, 这时会显示除了第一行之外的所有行, 因为第一行已经被删除了(实际文件并没有被删除,而只是显示的时候被删除了)
                sed -n '1d' abc 什么内容也不显示, 因为经过sed处理的行, 是个删除操作, 所以不现实.
                sed '2,$d' abc 删除abc中从第二行到最后一行所有的内容, 注意, $符号正则表达式中表示行末尾, 但是这里并没有说那行末尾, 就会指最后一行末尾, ^开头, 如果没有指定哪行开头, 那么就是第一行开头
                sed '$d' abc 只删除了最后一行, 因为并没有指定是那行末尾, 就认为是最后一行末尾
                sed '/test/d' abc 文件中所有带 test 的行, 全部删除
                sed '/test/a RRRRRRR' abc 将 RRRRRRR 追加到所有的带 test 行的下一行 也有可能通过行 sed '1,5c RRRRRRR' abc
                sed '/test/c RRRRRRR' abc 将 RRRRRRR 替换所有带 test 的行, 当然, 这里也可以是通过行来进行替换, 比如 sed '1,5c RRRRRRR' abc

        awk   一行一行的分析处理 awk '条件类型1{动作1}条件类型2{动作2}' filename
            另外还有3个变量, NF: 每一行处理的字段数, NR 目前处理到第几行 FS 目前的分隔符
            awk的处理流程是:
                1. 读第一行, 将第一行资料填入变量 $0, $1... 等变量中   默认的分隔符是空格键或tab键
                2. 依据条件限制, 执行动作
                3. 接下来执行下一行
            cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}' 
                首先定义分隔符为:, 然后判断, 注意看, 判断没有写在{}中, 
                然后执行动作, FS=":"这是一个动作, 赋值动作, 不是一个判断, 所以不写在{}中

